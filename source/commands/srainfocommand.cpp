//
//  srainfocommand.cpp
//  Mothur
//
//  Created by Sarah Westcott on 10/29/19.
//  Copyright Â© 2019 Schloss Lab. All rights reserved.
//

#include "srainfocommand.hpp"
#include "systemcommand.h"

//**********************************************************************************************************************
vector<string> SRAInfoCommand::setParameters(){
    try {
        CommandParameter paccnos("accnos", "InputTypes", "", "", "none", "none", "none","",false,true,true); parameters.push_back(paccnos);
        CommandParameter pPreFetchlocation("prefetch", "String", "", "", "", "", "","",false,false); parameters.push_back(pPreFetchlocation);
        CommandParameter pFasterQlocation("fasterq", "String", "", "", "", "", "","",false,false); parameters.push_back(pFasterQlocation);
        CommandParameter pcompress("gz", "Boolean", "", "F", "", "", "","",false,false); parameters.push_back(pcompress);
        CommandParameter pprocessors("processors", "Number", "", "1", "", "", "","",false,false,true); parameters.push_back(pprocessors);
        CommandParameter pmaxsize("maxsize", "Number", "", "20", "", "", "","",false,false,true); parameters.push_back(pmaxsize);
        CommandParameter pseed("seed", "Number", "", "0", "", "", "","",false,false); parameters.push_back(pseed);
        CommandParameter pinputdir("inputdir", "String", "", "", "", "", "","",false,false); parameters.push_back(pinputdir);
        CommandParameter poutputdir("outputdir", "String", "", "", "", "", "","",false,false); parameters.push_back(poutputdir);
        
        vector<string> myArray;
        for (int i = 0; i < parameters.size(); i++) {    myArray.push_back(parameters[i].name);        }
        return myArray;
    }
    catch(exception& e) {
        m->errorOut(e, "SRAInfoCommand", "setParameters");
        exit(1);
    }
}
//**********************************************************************************************************************
string SRAInfoCommand::getHelpString(){
    try {
        string helpString = "";
        helpString += "The sra.info command reads an accnos file containing sample names. It uses prefetch and fasterq_dump to download and extract the fastq files. The prefetch and fasterq_dump tools developed by NCBI, https://trace.ncbi.nlm.nih.gov/Traces/sra/sra.cgi?view=software. Mothur is compatible with version 2.9.6. \n";
        helpString += "The sra.info command parameters are accnos, fasterq, prefetch, maxsize, gz and processors.\n";
        helpString += "The accnos parameter is used to give the list of samples for download. This file can be generated by clicking on the Accession List button in the Select table on the SRA Run Selector page.\n";
        helpString += "The processors parameter allows you to specify how many processors you would like to use. The default is all available. \n";
        helpString += "The maxsize parameter allows you to limit the size of the files downloaded by prefetch. The default is 20 (20GB). \n";
        helpString += "The gz parameter allows you to compress the fastq files. The default is false. \n";
        helpString += "The fasterq parameter allows you to specify location of the fasterq_dump executable. By default mothur will look in its location and the location of MOTHUR_TOOLS if specified at compile time or set through the set.dir(tools=locationOfExternalTools) command. Ex. sra.info(accnos=SRR_Acc_List.txt.csv, fasterq=/usr/bin/fasterq-dump.2.10.1) or  sra.info(accnos=SRR_Acc_List.txt.csv, fasterq=/usr/local/fasterq_dump). Location and name of exe can be set.\n";
        helpString += "The prefetch parameter allows you to specify location of the prefetch executable. By default mothur will look in its location and the location of MOTHUR_TOOLS if specified at compile time or set through the set.dir(tools=locationOfExternalTools) command. Ex. sra.info(accnos=SRR_Acc_List.txt.csv, prefetch=/usr/bin/prefetch.2.10.1) or  sra.info(accnos=SRR_Acc_List.txt.csv, prefetch=/usr/local/prefetch). Location and name of exe can be set.\n";
        helpString += "The sra.info command should be in the following format: sra.info(accnos=yourAccnosFile)\n";
        helpString += "sra.info(sra=SRR_Acc_List.txt.csv) \n";
        return helpString;
    }
    catch(exception& e) {
        m->errorOut(e, "SRAInfoCommand", "getHelpString");
        exit(1);
    }
}
//**********************************************************************************************************************
string SRAInfoCommand::getOutputPattern(string type) {
    try {
        string pattern = "";
        
        if (type == "fastq") {  pattern = "[filename],fastq"; }
        else if (type == "file") {  pattern = "[filename],files"; }
        else if (type == "sra") {  pattern = "[filename],sra"; }
        else { m->mothurOut("[ERROR]: No definition for type " + type + " output pattern.\n"); m->setControl_pressed(true);  }
        
        return pattern;
    }
    catch(exception& e) {
        m->errorOut(e, "SRAInfoCommand", "getOutputPattern");
        exit(1);
    }
}
//**********************************************************************************************************************
SRAInfoCommand::SRAInfoCommand(){
    try {
        abort = true; calledHelp = true;
        setParameters();
        vector<string> tempOutNames;
        outputTypes["fastq"] = tempOutNames;
        outputTypes["file"] = tempOutNames;
    }
    catch(exception& e) {
        m->errorOut(e, "SRAInfoCommand", "SRAInfoCommand");
        exit(1);
    }
}
//***************************************************************************************************************

SRAInfoCommand::SRAInfoCommand(string option)  {
    try {
        abort = false; calledHelp = false;
        
        //allow user to run help
        if(option == "help") { help(); abort = true; calledHelp = true; }
        else if(option == "citation") { citation(); abort = true; calledHelp = true;}
        
        else {
            vector<string> myArray = setParameters();
            
            OptionParser parser(option);
            map<string,string> parameters = parser.getParameters();
            
            ValidParameters validParameter;
            map<string,string>::iterator it;
            
            //check to make sure all parameters are valid for command
            for (it = parameters.begin(); it != parameters.end(); it++) {
                if (!validParameter.isValidParameter(it->first, myArray, it->second)) {  abort = true;  }
            }
            
            //if the user changes the input directory command factory will send this info to us in the output parameter
            string inputDir = validParameter.valid(parameters, "inputdir");
            if (inputDir == "not found"){    inputDir = "";        }
            else {
                string path;
                it = parameters.find("accnos");
                //user has given a template file
                if(it != parameters.end()){
                    path = util.hasPath(it->second);
                    //if the user has not given a path then, add inputdir. else leave path alone.
                    if (path == "") {    parameters["accnos"] = inputDir + it->second;        }
                }
            }
            
            //initialize outputTypes
            vector<string> tempOutNames;
            outputTypes["fastq"] = tempOutNames;
            outputTypes["file"] = tempOutNames;
            outputTypes["sra"] = tempOutNames;
            
            //check for required parameters
            accnosfile = validParameter.validFile(parameters, "accnos");
            if (accnosfile == "not open") { accnosfile = ""; abort = true; }
            else if (accnosfile == "not found") { m->mothurOut("[ERROR]: The accnos parameter is required.\n");  abort = true; }
            
            outputDir = validParameter.valid(parameters, "outputdir");        if (outputDir == "not found"){
                outputDir = "";
                outputDir += util.hasPath(accnosfile); //if user entered a file with a path then preserve it
            }
            
            string temp = validParameter.valid(parameters, "processors");    if (temp == "not found"){    temp = current->getProcessors();    }
            processors = current->setProcessors(temp);
            
            temp = validParameter.valid(parameters, "gz");        if (temp == "not found") { temp = "F"; }
            compressGZ = util.isTrue(temp);
            
            temp = validParameter.valid(parameters, "maxsize"); if (temp == "not found"){    temp = "20";    }
            util.mothurConvert(temp, maxSize);
            maxSize *= 1000000;
            
            vector<string> versionOutputs;
            bool foundTool = false;
            string path = current->getProgramPath();
            string programName = "fasterq-dump"; programName += EXECUTABLE_EXT;
            
            fasterQLocation = validParameter.valid(parameters, "fasterq");
            if (fasterQLocation == "not found") {
                fasterQLocation = "";
                foundTool = util.findTool(programName, fasterQLocation, path, versionOutputs, current->getLocations());
            }else {
                //test to make sure vsearch exists
                ifstream in;
                fasterQLocation = util.getFullPathName(fasterQLocation);
                bool ableToOpen = util.openInputFile(fasterQLocation, in, "no error"); in.close();
                if(!ableToOpen) {
                    m->mothurOut(fasterQLocation + " file does not exist or cannot be opened, ignoring.\n"); fasterQLocation = "";
                    programName = util.getSimpleName(fasterQLocation); fasterQLocation = "";
                    foundTool = util.findTool(programName, fasterQLocation, path, versionOutputs, current->getLocations());
                }
            }
          
            if (foundTool && !abort) { //check fasterq_dump version
                if (versionOutputs.size() >= 3) {
                    string version = versionOutputs[2];
                                                
                    if (version != "2.10.1") {
                        m->mothurOut("[ERROR]: " + programName + " version found = " + version + ". Mothur requires version 2.10.1 which is distributed with mothur's executable or available for download here, https://trace.ncbi.nlm.nih.gov/Traces/sra/sra.cgi?view=software\n");  abort = true;
                    }else { m->mothurOut("Using " + programName + " version " + version + ".\n"); }
                }
            }
            
            foundTool = false;
            path = current->getProgramPath();
            programName = "prefetch"; programName += EXECUTABLE_EXT;
            versionOutputs.clear();
            
            prefetchLocation = validParameter.valid(parameters, "prefetch");
            if (prefetchLocation == "not found") {
                prefetchLocation = "";
                foundTool = util.findTool(programName, prefetchLocation, path, versionOutputs, current->getLocations());
            }else {
                //test to make sure vsearch exists
                ifstream in;
                prefetchLocation = util.getFullPathName(prefetchLocation);
                bool ableToOpen = util.openInputFile(prefetchLocation, in, "no error"); in.close();
                if(!ableToOpen) {
                    m->mothurOut(prefetchLocation + " file does not exist or cannot be opened, ignoring.\n"); prefetchLocation = "";
                    programName = util.getSimpleName(prefetchLocation); prefetchLocation = "";
                    foundTool = util.findTool(programName, prefetchLocation, path, versionOutputs, current->getLocations());
                }
            }
            
            if (foundTool && !abort) { //check fasterq_dump version
                if (versionOutputs.size() >= 3) {
                    string version = versionOutputs[2];
                    
                    if (version != "2.10.1") {
                        m->mothurOut("[ERROR]: " + programName + " version found = " + version + ". Mothur requires version 2.10.1 which is distributed with mothur's executable or available for download here, https://trace.ncbi.nlm.nih.gov/Traces/sra/sra.cgi?view=software\n");  abort = true;
                    }else { m->mothurOut("Using " + programName + " version " + version + ".\n"); }
                }
            }
            
            if (m->getDebug()) { m->mothurOut("[DEBUG]: fasterq-dump location using " + fasterQLocation + "\n"); m->mothurOut("[DEBUG]: prefetch location using " + prefetchLocation + "\n"); }
        }
    }
    catch(exception& e) {
        m->errorOut(e, "SRAInfoCommand", "SRAInfoCommand");
        exit(1);
    }
}
//***************************************************************************************************************
int SRAInfoCommand::execute(){
    try{
        
        if (abort) { if (calledHelp) { return 0; }  return 2;    }
        
        set<string> samples = util.readAccnos(accnosfile);

        map<string, string> variables;
        string thisOutputDir = outputDir;
        if (outputDir == "") { thisOutputDir = util.hasPath(accnosfile); }
        variables["[filename]"] = thisOutputDir + util.getRootName(util.getSimpleName(accnosfile));
        string fileFileName = getOutputFileName("file",variables);
        ofstream out; util.openOutputFile(fileFileName, out);
        outputNames.push_back(fileFileName); outputTypes["file"].push_back(fileFileName);
        
        int count = 0;
        for (set<string>::iterator it = samples.begin(); it != samples.end(); it++) {
            
            m->mothurOut("\n>>>>>\tProcessing sample " + *it + " (" + toString(count+1) + " of " + toString(samples.size()) + ")\t<<<<<\n"); count++;
            
            string downloadedFile = runPreFetch(*it);
            
            if (downloadedFile != "fail") {
                vector<string> filenames;
                bool hasBoth = runFastqDump(downloadedFile, filenames);
                
                if (hasBoth) {
                    if (compressGZ) {
                        string inputString = "gzip -f " + filenames[0];
                        runSystemCommand(inputString);
                        util.mothurRemove(filenames[0]);
                        inputString = "gzip -f " + filenames[1];
                        runSystemCommand(inputString);
                        util.mothurRemove(filenames[1]);
                        
                        outputNames.push_back(filenames[0]+".gz"); outputTypes["fastq"].push_back(filenames[0]+".gz");
                        outputNames.push_back(filenames[1]+".gz"); outputTypes["fastq"].push_back(filenames[1]+".gz");
                        
                        out << *it << '\t' << filenames[0]+".gz"<< '\t' << filenames[1]+".gz" << endl;
                    }else {
                        outputNames.push_back(filenames[0]); outputTypes["fastq"].push_back(filenames[0]);
                        outputNames.push_back(filenames[1]); outputTypes["fastq"].push_back(filenames[1]);
                        
                        out << *it << '\t' << filenames[0] << '\t' << filenames[1] << endl;
                    }
                    
                }
            }
        }
        out.close();
        
        //remove if not filled
        if (util.isBlank(fileFileName)) { util.mothurRemove(fileFileName); }
        
        string currentName = "";
        itTypes = outputTypes.find("file");
        if (itTypes != outputTypes.end()) {
            if ((itTypes->second).size() != 0) { currentName = (itTypes->second)[0]; current->setFileFile(currentName); }
        }
        
        m->mothurOut("\nOutput File Names: \n");
        for (int i = 0; i < outputNames.size(); i++) {    m->mothurOut(outputNames[i] +"\n");     } m->mothurOutEndLine();
        
        return 0;
    }
    catch(exception& e) {
        m->errorOut(e, "SRAInfoCommand", "execute");
        exit(1);
    }
}
//***************************************************************************************************************
string SRAInfoCommand::runPreFetch(string sampleName){
    try{
        double_t start = time(NULL);
        vector<char*> cPara;
        string prefetchCommand = prefetchLocation;
        prefetchCommand = "\"" + prefetchCommand + "\" " + sampleName + " ";
        
        char* tempPrefetch;
        tempPrefetch= new char[prefetchCommand.length()+1];
        *tempPrefetch = '\0';
        strncat(tempPrefetch, prefetchCommand.c_str(), prefetchCommand.length());
        cPara.push_back(tempPrefetch);
        
        if (maxSize != 20000000) {
            //-X|--max-size <size>             maximum file size to download in KB (exclusive). Default: 20G
            char* maxs = new char[3];     maxs[0] = '\0'; strncat(maxs, "-X", 2);
            cPara.push_back(maxs);
            string msize = toString(maxSize);
            char* tempSize = new char[msize.length()+1];
            *tempSize = '\0'; strncat(tempSize, msize.c_str(), msize.length());
            cPara.push_back(tempSize);
        }
       
        //-o|--outfile                     output-file
        char* outputFile = new char[3];     outputFile[0] = '\0'; strncat(outputFile, "-o", 2);
        cPara.push_back(outputFile);
        map<string, string> variables;
        variables["[filename]"] = outputDir + util.getRootName(util.getSimpleName(sampleName))+".";
        string outputFileName = getOutputFileName("sra",variables);
        char* tempoutfile = new char[outputFileName.length()+1];
        *tempoutfile = '\0'; strncat(tempoutfile, outputFileName.c_str(), outputFileName.length());
        cPara.push_back(tempoutfile);
        
        char** preFetchParameters;
        preFetchParameters = new char*[cPara.size()];
        string commandString = "";
        for (int i = 0; i < cPara.size(); i++) {  preFetchParameters[i] = cPara[i];  commandString += toString(cPara[i]) + " "; }
        
#if defined NON_WINDOWS
#else
        commandString = "\"" + commandString + "\"";
#endif
        //free memory
        for(int i = 0; i < cPara.size(); i++)  {  delete cPara[i];  }
        delete[] preFetchParameters;
        
        if (m->getDebug()) { m->mothurOut("[DEBUG]: prefetch command = " + commandString + ".\n"); }
        //m->mothurOut("prefetch command = " + commandString + ".\n");
        
        ifstream inTest;
        if (util.openInputFile(outputFileName, inTest, "no error")) { m->mothurOut("\n" + outputFileName + " is found locally, skipping prefetch.\n\n"); return outputFileName; }
            
        //run system command
        runSystemCommand(commandString);
        
        //check for output files
        ifstream in;
        if (!util.openInputFile(outputFileName, in, "no error")) {
            m->mothurOut("\n\n[ERROR]: prefetch was unable to download sample " + sampleName + ", skipping.\n\n"); return "fail";
        }else { outputNames.push_back(outputFileName); outputTypes["sra"].push_back(outputFileName); }
        
        m->mothurOut("It took " + toString(time(NULL)-start)+ " seconds to download sample " + sampleName + ".\n");
        
        return outputFileName;
    }
    catch(exception& e) {
        m->errorOut(e, "SRAInfoCommand", "runPreFetch");
        exit(1);
    }
}
//***************************************************************************************************************
bool SRAInfoCommand::runFastqDump(string sampleFile, vector<string>& filenames){
    try{
        
        vector<char*> cPara;
        string fasterQCommand = fasterQLocation;
        fasterQCommand = "\"" + fasterQCommand + "\" " + sampleFile + " ";
        
        char* tempFasterQ;
        tempFasterQ= new char[fasterQCommand.length()+1];
        *tempFasterQ = '\0';
        strncat(tempFasterQ, fasterQCommand.c_str(), fasterQCommand.length());
        cPara.push_back(tempFasterQ);
        
        //--force - overwrite output files if they exist
        //char* force = new char[8];  force[0] = '\0'; strncat(force, "--force", 7);
        //cPara.push_back(force);
        
        //-S|--split-files                 write reads into different files
        char* splitFiles = new char[3];     splitFiles[0] = '\0'; strncat(splitFiles, "-S", 2);
        cPara.push_back(splitFiles);
        
        //-3|--split-3                     writes single reads in special file
        char* splitSingleFiles = new char[3];     splitSingleFiles[0] = '\0'; strncat(splitSingleFiles, "-3", 2);
        cPara.push_back(splitSingleFiles);
        
        //--threads=processors
        char* threads = new char[10];  threads[0] = '\0'; strncat(threads, "--threads", 9);
        cPara.push_back(threads);
        string numProcessors = toString(processors);
        char* tempThreads = new char[numProcessors.length()+1];
        *tempThreads = '\0'; strncat(tempThreads, numProcessors.c_str(), numProcessors.length());
        cPara.push_back(tempThreads);
        
        //-o|--outfile                     output-file
        char* outputFile = new char[3];     outputFile[0] = '\0'; strncat(outputFile, "-o", 2);
        cPara.push_back(outputFile);
        map<string, string> variables;
        variables["[filename]"] = outputDir + util.getRootName(util.getSimpleName(sampleFile));
        string outputFileName = getOutputFileName("fastq",variables);
        char* tempoutfile = new char[outputFileName.length()+1];
        *tempoutfile = '\0'; strncat(tempoutfile, outputFileName.c_str(), outputFileName.length());
        cPara.push_back(tempoutfile);
        
        char** fasterQParameters;
        fasterQParameters = new char*[cPara.size()];
        string commandString = "";
        for (int i = 0; i < cPara.size(); i++) {  fasterQParameters[i] = cPara[i];  commandString += toString(cPara[i]) + " "; }
        
#if defined NON_WINDOWS
#else
        commandString = "\"" + commandString + "\"";
#endif
        //free memory
        for(int i = 0; i < cPara.size(); i++)  {  delete cPara[i];  }
        delete[] fasterQParameters;
        
        if (m->getDebug()) { m->mothurOut("[DEBUG]: fasterq_dump command = " + commandString + ".\n"); }
        //m->mothurOut("fasterq_dump command = " + commandString + ".\n");
        
        ifstream testfin, testrin;
        string ffastq = outputDir + util.trimString(util.getRootName(util.getSimpleName(sampleFile)), 1) +"_1.fastq";
        string rfastq = outputDir + util.trimString(util.getRootName(util.getSimpleName(sampleFile)), 1) +"_2.fastq";
        
        bool found = false;
        string tag = "";
        if (compressGZ) { tag= ".gz";  }
        
        if (util.openInputFile(ffastq+tag, testfin, "no error")) {
            if (util.openInputFile(rfastq+tag, testrin, "no error")) {
                m->mothurOut("\n" + ffastq+tag + " and " +  rfastq+tag + " found locally, skipping fasterq_dump.\n\n"); found = true;
            }
        }
        
        if (!found) { runSystemCommand(commandString); }
        
        //check for output files. trimstring removes last character
        ifstream fin, rin;
        bool hasBoth = true;
        if (util.openInputFile(ffastq, fin, "no error")) {
            filenames.push_back(ffastq);
            fin.close();
        }else { hasBoth = false; }
        
        if (util.openInputFile(rfastq, rin, "no error")) {
            filenames.push_back(rfastq);
            rin.close();
        }else { hasBoth = false; }
        
        return hasBoth;
    }
    catch(exception& e) {
        m->errorOut(e, "SRAInfoCommand", "runFastqDump");
        exit(1);
    }
}
/**************************************************************************************************/
void SRAInfoCommand::runSystemCommand(string inputString){
    try{
        m->mothurOut("/******************************************/\n");
        m->mothurOut("\nRunning command: system(" + inputString + ")\n");
        current->setMothurCalling(true);
        
        Command* systemCommand = new SystemCommand(inputString);
        systemCommand->execute();
    
        delete systemCommand;
        current->setMothurCalling(false);
        
        m->mothurOut("/******************************************/\n");
    }
    catch(exception& e) {
        m->errorOut(e, "SRAInfoCommand", "runSystemCommand");
        exit(1);
    }
}
/**************************************************************************************************/
        
